/* Copyright 1990-2007, Jsoftware Inc.  All rights reserved.               */
/* Licensed use only. Any other use is in violation of copyright.          */
/*                                                                         */
/* Type Definitions                                                        */

#define U unsigned

#if (SYS & SYS_UNIX)
#define _stdcall      
#endif

#ifdef _WIN32
#define CDPROC
#elif defined(__GNUC__)
#define CDPROC __attribute__ ((visibility ("default")))
#else
#define CDPROC
#endif

#if SY_64
typedef long long          A1;
typedef unsigned long long BT;
typedef long long          I;
typedef long long          SB;
typedef unsigned long long UI;
typedef unsigned long long UIL;   /* for typecast 8 byte double */
typedef long long          IL;
//NANFLAG is used internally as a special value that is not generated by any normal operations.  It is represented in integer form,
// and is used only when SZI==SZD
#define NANFLAG 0x7ff28da91LL  // signaling NaN with a particular value

#else
typedef long               A1;
typedef unsigned long      BT;
typedef long               I;
typedef long               SB;
typedef unsigned long      UI;
typedef unsigned long long UIL;
typedef long long          IL;
#endif

typedef char               B;
typedef unsigned char      C;
typedef char*              Ptr;
typedef short              S;
typedef short              C2;
typedef unsigned int       C4;
typedef unsigned char      UC;
typedef unsigned short     US;
typedef unsigned short     U2;
typedef unsigned int       UINT;
typedef int                I4;
typedef unsigned int       UI4;
typedef double             D;
typedef float              DS;
typedef FILE*              F;

typedef long double        LD;

// This is the main structure for J entities
typedef US                 RANKT;
#define RANKTX             16   // # bits in a RANKT
#define RANKTMSK           (((I)1<<RANKTX)-1)
#define R2MAX              ((RMAX<<RANKTX)+RMAX)  // max value of a RANK2T
typedef UI4                RANK2T;  // 2 ranks, (l<<16)|r
#define RANK2TX            32   // # bits in a RANK2T
#define RANK2TMSK           0xFFFFFFFFU
typedef I                  FLAGT;
typedef I4                LX;  // index of an L block in JT(jt,sympv)

typedef struct AD AD;
typedef AD *A;

// Flag bits in the low-order part of jt - used only if the function being called understands inplacing
#define JTINPLACEWX     0   // turn this on in jt to indicate that w can be inplaced
#define JTINPLACEW      (((I)1)<<JTINPLACEWX)
#define JTINPLACEAX     1   // turn this on in jt to indicate that a can be inplaced.  Must be 1+JTINPLACEWX
#define JTINPLACEA      (((I)1)<<JTINPLACEAX)
// following bit used as arg to parse
#define JTFROMEXECX    0   // parser call from ". - makes some features unavailable
#define JTFROMEXEC      (((I)1)<<JTFROMEXECX)
// following bit used as arg to jtfolk
#define JTFOLKNOHFNX    2   // set to get the generic fork that does not expect the hfn in localuse
#define JTFOLKNOHFN      (((I)1)<<JTFOLKNOHFNX)
// following bit is used on input to jtcvt only
#define JTNOFUZZX       1   // comparison on legal float conversion should be exact
#define JTNOFUZZ        (((I)1)<<JTNOFUZZX)
// following bits is used inside/input to jtlrep only
#define JTNORESETERRX   0   // create fully parenthesized output
#define JTNORESETERR        (((I)1)<<JTNORESETERRX)
#define JTPARENSX       1   // create fully parenthesized output
#define JTPARENS        (((I)1)<<JTPARENSX)
// following bits are passed into jpr/jpr1/immex/immea/showerr/wri
#define JTPRTYO         7  // output class, see MTYO*
#define JTPRNOSTDOUTX   3   // set to suppress typing sentence result on stdout (as in scripts)
#define JTPRNOSTDOUT    (((I)1)<<JTPRNOSTDOUTX)
// following bit is used in sort/grade to indicate sort direction
#define JTDESCENDX      2   // direction of sort
#define JTDESCEND       (((I)1)<<JTDESCENDX)
// following 2 bits used as input to jtsymbis only
#define JTFINALASGNX    0   // turn this on in jt to indicate that the assignment is final and does not have to worry about protecting the input value
#define JTFINALASGN     (((I)1)<<JTFINALASGNX)
#define JTASSIGNSYMNON0X 1   // the a value is jt->assignsym and does not need to be looked up
#define JTASSIGNSYMNON0     (((I)1)<<JTASSIGNSYMNON0X)
// following bits are used in thorn for boxes
#define JTTHORNYX       2  // 0, 1, or 2 for min/center/max for positioning of formatted data in boxes: horiz
#define JTTHORNY    (((I)3)<<JTTHORNYX)
#define JTTHORNXX       4  // 0, 1, or 2 for min/center/max for positioning of formatted data in boxes: vert
#define JTTHORNX    (((I)3)<<JTTHORNXX)


// Next flag must match result.h and VF2 flags, and must be above ZZFLAGBOXATOP
#define JTWILLBEOPENEDX 4   // result of this exec will be opened immediately, so it can contain virtual references to an input to the current verb
     // Note: this flag MUST NOT equal BOX, or BOX<<1, or 1 or 2
#define JTWILLBEOPENED  (((I)1)<<JTWILLBEOPENEDX)
#define JTEMPTYX        5  // in va2, this bit indicates the result is empty
#define JTEMPTY         (((I)1)<<JTEMPTYX)
#define JTRETRYX        6  // in va2, this bit is set to indicate that the current execution is a retry
#define JTRETRY         (((I)1)<<JTRETRYX)

// Next flag must match result.h and VF2 flags, and must be above ZZFLAGBOXATOP
#define JTCOUNTITEMSX   7   // result of this exec will be go into ;, so an item count in m would be helpful
#define JTCOUNTITEMS    (((I)1)<<JTCOUNTITEMSX)

#define JTFLAGMSK       255  // mask big enough to cover all defined flags
#define JTALIGNBDY      MAX(8192,(MAXTASKSRND<<LGTHREADBLKSIZE))  // jt is aligned on this boundary - all lower bits are 0 (the value is the size of an SDRAM page, to avoid row precharges while accessing jt)

struct AD {
 union {
  I k;
  A chain;   // used when block is on free chain
  A globalst;  // for local symbol tables (SYMB types), AK points to the active global symbol table when the current sentence started parsing
  A locpath;  // for non-local SYMB (named and numeric), AK points to the path, which uses AAV0 and stores addresses of SYMBs
 } kchain;
 FLAGT flag;
 union {
  I m;  // Multi-use field. (1) For NJA/SMM blocks, size of allocation. (2) for any non-NJA value that has ever been assigned to a name, AM holds NVR information.
        // Bit 0 is set to indicate that AM has NVR data (all result values start with AM pointing to tstack with bit 0 clear); bit 1 is set if a free for the value has
        // been deferred and must be applied when the NVR count goes to 0; bits 2 and up are the NVR count, i. e. the number of times the value is on the NVR stack
        // Bit 0 is set to initiate this use when a value is assigned to a name for the first time (and NVR count is set to 0 then)
        // (3) for SYMB tables for explicit definitions, the address of the calling symbol table; for other SYMB tables,
        // a Bloom filter of the hashes assigned in the locale (using the low bits of the hash) (4) for the block
        // holding the amend offsets in x u} y, the number of axes of y that are built into the indexes in u
        // (5) in the return from wordil, holds the number of words if any final NB. is discarded; (6) in the result of indexofsub when called for FORKEY, contains the
        // number of partitions found; (7) in the self block for y L: n and u S: n, the address of the fs block for u; (8) in the call to jtisf (multiple assignment), holds the
        // address of the symbol table being assigned to (9) in the y block internal to pv.c, used for flags (10) in hashtables in x15.c and in tickers, the number of entries that have been hashed
        // (11) in file-lock list and file-number list, the # valid files (14) in JT(jt,stnum), the numbered-locale table, the number of locales outstanding
  A back; // For VIRTUAL blocks, points to backing block
  A *zaploc;  // For all blocks, AM initially holds a pointer to the place in the tpop stack (or hijacked tpop stack) that points back to the allocated block.  This value is guaranteed
        // to remain valid as long as the block is nonvirtual inplaceable and might possibly return as a result to the parser or result assembly  (in cases under m above, the block cannot become such a result)
} mback;
 union {
  I t;  // type
  A proxychain;  // used when block is on free chain
 } tproxy;
 I c;  // usecount
//  NOTE!! result.h faux cellshape block depends on n, r, and s being in place from here to the end of this struct, with 2 Is from n to s
 I n;  // # atoms - always 1 for sparse arrays
#if C_LE
 RANKT r;  // rank
 US h;   // reserved for allocator.  Not used for AFNJA memory
#if BW==64
 US origin;
 S lock;   // can be used as a lock
#endif
#else
#if BW==64
 S lock;   // can be used as a lock
 US origin;
#endif
 US h;   // reserved for allocator.  Not used for AFNJA memory
 RANKT r;  // rank
#endif
 I s[1];   // shape starts here.  NOTE!! s[0] is always OK to fetch.  We allocate 8 words minimum and s[0] is the last.
  // when AFUNIFORMITEMS is set, s[0] holds the number of items in the raze of the block
};

typedef struct {A a,t;}TA;
typedef A                (*AF)();
typedef UI               (*UF)();
typedef I                (*VF)();  // action verb for atomic dyad
typedef I                (*VA1F)();  // action verb for atomic monad
typedef void             (*VARPSF)();  // action verb for atomic reduce/prefix/suffix routine
typedef B                (*CMP)();    /* comparison function in sort     */
typedef A                  X;
typedef struct {X n,d;}    Q;
typedef struct {D re,im;}  Z;
typedef union {D d;UINT i[2];UI ui;} DI;

#if (SYS & SYS_PC+SYS_MACINTOSH)        /* for use by the session manager  */
typedef S SI;
#else
typedef I SI;
#endif

/* Fields of type A                                                        */

#define AK(x)           ((x)->kchain.k)        /* offset of ravel wrt x           */
#define AKASA(x)        ((x)->kchain.chain)       // the AK field for synthetic self blocks
#define AKGST(x)        ((x)->kchain.globalst)        // global symbol table for this local symbol table
#define AFLAG(x)        ((x)->flag)     /* flag                            */
#define AM(x)           ((x)->mback.m)        /* Max # bytes in ravel            */
#define ABACK(x)        ((x)->mback.back)        /* In virtual noun, pointer to backing block            */
#define AZAPLOC(x)      ((x)->mback.zaploc)    // on allocation, the address of the tstack entry that will free the block
#define AZAPLOCVOL(x)   (((volatile AD *)x)->mback.zaploc)    // on allocation, the address of the tstack entry that will free the block
#define AZAPLOCV(x)     ((A*)((x)->s[(x)->r]))    // for virtual blocks,  the address of the tstack entry that will free the block
#define AT(x)           ((x)->tproxy.t)        /* Type; one of the #define below  */
#define AC(x)           ((x)->c)        /* Reference count.                */
#define AN(x)           ((x)->n)        /* # elements in ravel             */
#define AR(x)           ((x)->r)        /* Rank                            */
#define SMMAH           7L   // number of header words in old-fashioned SMM alloc
#define NORMAH          7L   // number of header words in new system
#define AS(x)           ((x)->s)        // Because s is an array, AS(x) is a pointer to the shape, which is in s.  The shape is stored in the fixed position s.

// The following fields are used for private communication between /. and ;. and inside ;. for the fret buffer.
#define CUTFRETCHAIN(x) ((x)->kchain.chain)  // pointer to next block of frets
#define CUTFRETCOUNT(x) ((x)->kchain.k)  // when passed into cut, this is # frets.  Overwritten by CUTFRETCHAIN
#define CUTFRETFRETS(x) ((UC*)((x)->s))   // address of first fret
#define CUTFRETEND(x)   ((x)->n)   // address of last+1 fret

#if SY_64
#define AKXR(x)         (SZI*(NORMAH+(x)))
#define WP(t,n,r)       (SMMAH+ r   +(1&&t&LAST0)+(((t&NAME?sizeof(NM):0)+((n)<<bplg(t))+SZI-1)>>LGSZI))  // # I to allocate
#else
#define AKXR(x)         (SZI*(NORMAH+((x)|1)))
#define WP(t,n,r)       (SMMAH+(r|1)+  (1&&t&LAST0)+(((t&NAME?sizeof(NM):0)+((n)<<bplg(t))+SZI-1)>>LGSZI))
/* r|1 to make sure array values are double-word aligned */
#endif
#define AKX(x)          AKXR(AR(x))

#define AV(x)           ( (I*)((C*)(x)+AK(x)))  /* pointer to ravel        */
#define BAV(x)          (      (B*)(x)+AK(x) )  /* boolean                 */
#define CAV(x)          (      (C*)(x)+AK(x) )  /* character               */
#define CAV0(x)         (((C*)(x)+AKXR(0)))  // character in non-virtual rank-0 array  (allocated as rank 0, that is)
#define CAV1(x)         (((C*)(x)+AKXR(1)))  // character in non-virtual rank-1 array
#define CAV2(x)         (((C*)(x)+AKXR(2)))  // character in non-virtual rank-2 array
#define UCAV(x)         (     (UC*)(x)+AK(x) )  /* unsigned character      */
#define USAV(x)         ((US*)((C*)(x)+AK(x)))  /* wchar                   */
#define UAV(x)          (     (UC*)(x)+AK(x) )  /* unsigned character      */
#define UIAV(x)         ((UI*)((C*)(x)+AK(x)))  /* unsigned integer      */
#define UI4AV(x)        ((UI4*)((C*)(x)+AK(x)))  /* unsigned 32-bit int      */
#define C4AV(x)         ((C4*)((C*)(x)+AK(x)))  /* literal4                */
#define NAV(x)          ((NM*)((C*)(x)+AKXR(1)))  // name, which is always allocated as rank 1, for some reason
#define NAVV(x)         ((volatile NM*)((C*)(x)+AKXR(1)))  // name, which is always allocated as rank 1, for some reason
#define IAV(x)          AV(x)                   /* integer                 */
#define IAV0(x)         ((I*)((C*)(x)+AKXR(0)))  // integer in a stack- or heap-allocated atom (rank 0 - used for internal tables)
#define IAV1(x)         ((I*)((C*)(x)+AKXR(1)))  // integer in a stack- or heap-allocated list (rank 1 - used for internal tables that need alignment or need AS[0])
#define IAV2(x)         ((I*)((C*)(x)+AKXR(2)))  // integer in a stack- or heap-allocated list (rank 2)
#define BAV0(x)         ( (C*)((C*)(x)+AKXR(0)) )  // Boolean when rank is 0 - fixed position (known to avoid segfault)
#define LXAV0(x)        ( (LX*)((C*)(x)+AKXR(0)) )  // Symbol when rank is 0 - fixed position (for SYMB hash tables).  Note AK() is used in SYMB tables
#define LAV0(x)         ( (L*)((C*)(x)+AKXR(0)) )  // Symbol array when rank is 0 - used for the symbol pool
#define DAV(x)          ( (D*)((C*)(x)+AK(x)))  /* double                  */
#define DAV0(x)         ( (D*)((C*)(x)+AKXR(0)))  // double atom
#define DAV2(x)         ( (D*)((C*)(x)+AKXR(2)) )  // Double when rank is 2 - fixed position (for matrix inversion)
#define ZAV(x)          ( (Z*)((C*)(x)+AK(x)))  /* complex                 */
#define XAV(x)          ( (X*)((C*)(x)+AK(x)))  /* extended                */
#define QAV(x)          ( (Q*)((C*)(x)+AK(x)))  /* rational                */
#define AAV(x)          ( (A*)((C*)(x)+AK(x)))  /* boxed                   */
#define AAV0(x)         ((A*)((C*)(x)+AKXR(0)))  // A block in a stack- or heap-allocated atom (rank 0 - used for internal tables)
#define AAV1(x)         ((A*)((C*)(x)+AKXR(1)))  // A block in a stack- or heap-allocated list (rank 1)
#define VAV(x)          ( (V*)((C*)(x)+AK(x)))  /* verb, adverb, conj      */
#define FAV(x)          ( (V*)((C*)(x)+AKXR(0)) )  // verb, adverb, conj - always at fixed offset
#define FAVV(x)         ( (volatile V*)((C*)(x)+AKXR(0)) )  // verb, adverb, conj volatile to avoid delayed fetch
#define PAV(x)          ( (P*)((C*)(x)+AK(x)))  /* sparse                  */
#define SBAV(x)         ((SB*)((C*)(x)+AK(x)))  /* symbol                  */
#define SBUV4(x)        ((SBU*)((C*)(x)+AKXR(4)))  // symbol, nonvirtual rank 4
#define voidAV(x)       ((void*)((C*)(x)+AK(x)))  // unknown
#define voidAV0(x)       ((void*)((C*)(x)+AKXR(0)))  // unknown, but scalar
#define voidAVn(x,n)     ((void*)((C*)(x)+AKXR(n)))  // unknown, but rank is known
#define UNLXAV0(x)      ((A)((I)(x)-AKXR(0)))   // go from a pointer to LXAV0 back to the base of the A block

#if C_LE
#define BIV0(w) (IAV(w)[0]&(1-((AT(w)&INT)>>(INTX-1))))  // the first (presumably only) value in w, when w is an INT or B01 type
#endif

/* Types for AT(x) field of type A                                         */
/* Note: BOOL name conflict with ???; SCHAR name conflict with sqltypes.h  */

// NOTE!! the length of NOUN types must be power-of-2 multiples because of jtamend2

// NOTE: all noun types must be below all parsable non-nouns

#define B01X 0
#define B01             ((I)1L<<B01X)           /* B  boolean                      */
#define B01SIZE         sizeof(B)       // length of 1 atom
#define LITX 1
#define LIT             ((I)1L<<LITX)           /* C  literal (character)          */
#define LITSIZE sizeof(C)
#define INTX 2
#define INT             ((I)1L<<INTX)           /* I  integer                      */
#define INTSIZE sizeof(I)
#define FLX 3
#define FL              ((I)1L<<FLX)           /* D  double (IEEE floating point) */
#define FLSIZE sizeof(D)
#define CMPXX 4
#define CMPX            ((I)1L<<CMPXX)          /* Z  complex                      */
#define CMPXSIZE sizeof(Z)
#define BOXX 5
#define BOX             ((I)1L<<BOXX)          /* A  boxed                        */
#define BOXSIZE sizeof(A)
#define XNUMX 6
#define XNUM            ((I)1L<<XNUMX)          /* X  extended precision integer   */
#define XNUMSIZE sizeof(X)
#define RATX 7
#define RAT             ((I)1L<<RATX)         /* Q  rational number              */
#define RATSIZE sizeof(Q)
// No size for BIT, since it is fractional
// Bit 8-9 unused
#define SBTX 16
#define SBT             ((I)1L<<SBTX)       /* SB symbol                       */
#define SBTSIZE sizeof(SB)
#define C2TX 17
#define C2T             ((I)1L<<C2TX)      /* C2 unicode (2-byte characters)  */
#define C2TSIZE sizeof(US)
#define C4TX 18
#define C4T             ((I)1L<<C4TX)         /* C4 unicode (4-byte characters)  */
#define C4TSIZE sizeof(C4)
#define XDX 19
#define XD              ((I)1L<<XDX)   // DX extended floating point   used to represent intolerant compare in jtiosc
#define XDSIZE sizeof(DX)
#define XZX 20
#define XZ              ((I)1L<<XZX)   /* ZX extended complex             */
#define XZSIZE sizeof(ZX)

#define LASTNOUNX XZX    // index of last noun bit

// upper flags may be used, except for RPAR and CONJ (used as stack count in parser), LPAR and ASGN (used in parser to calculate initial stack count), CONW (always means ASGNTONAME in parser)
// if ADV is used, some tests may need to change
#define NAMEX 21
#define NAME            ((I)1L<<NAMEX)    /* NM name                         */
#define NAMESIZE sizeof(C)   // when we allocate a NAME type, the length is the length of the name string
// NOTE: SYMB, and MARK are used as flags in names, see below
#define MARKX 22  // don't try to move this! it ripples through and breaks JTflags
#define MARK            ((I)1L<<MARKX)     /* I  end-of-stack marker          */
#define MARKSIZE sizeof(I)
#define ADVX 23
#define ADV             ((I)1L<<ADVX)      /* V  adverb                       */
#define ADVSIZE sizeof(V)
// NOTE: SYMB is set in an ADV value to indicate that the value is nameless, see below
#define ASGNX 24
#define ASGN            ((I)1L<<ASGNX)     /* I  assignment                   */
#define ASGNSIZE sizeof(I)     // only 1 byte, but all non-DIRECT are fullword multiples
// BOTE: SYMB and CONW are used as flags in ASGN, see below
#define SYMBX 25
#define SYMB            ((I)1L<<SYMBX)     /* I  locale (symbol table)        */
#define SYMBSIZE sizeof(LX)
#define CONWX 26
#define CONW            ((I)1L<<CONWX)    /* CW control word                 */
#define CONWSIZE sizeof(CW)
// NOTE: The parser assumes that CONW always means ASGNTONAME, so don't use it in any parseable type except ASGN
#define VERBX 27
#define VERB            ((I)1L<<VERBX)      /* V  verb                         */
#define VERBSIZE sizeof(V)  // Note: size of ACV in bp() is INTSIZE because the allocation in fdef() is of INTs
// NOTE: VERB must be above all NOUN bits because of CONJCASE.  Must be >ADV because of AVN testing in parser
// es delayline is parser expects VERBX <= 27
#define LPARX 28
#define LPAR            ((I)1L<<LPARX)    /* I  left  parenthesis            */
// note: LPAR used as flag to cvt() see below; also as modifier to ADV type
#define LPARSIZE sizeof(I)
// CONJ must be 1 bit below RPAR, with no parsable type (including any flags that might be set, see below) in CONJ or RPAR
#define CONJX 29
#define CONJ            ((I)1L<<CONJX)     /* V  conjunction                  */
#define CONJSIZE sizeof(V)
#define RPARX 30
#define RPAR            ((I)1L<<RPARX)   /* I  right parenthesis            */
#define RPARSIZE sizeof(I)

// ** ASGN type can have the following informational bits set along with ASGN
#define ASGNLOCALX      SYMBX     // set for =. (but not when assigning to locative)    aliases with SYMB
#define ASGNLOCAL       ((I)1L<<ASGNLOCALX)     // set for =. (but not when assigning to locative)    aliases with SYMB
#define ASGNTONAME      ((I)1L<<CONWX)     // set when assignment is to name    aliases with CONW
// NOTE: The parser assumes that CONW always means ASGNTONAME, so don't use it in any parseable type except ASGN
// ** NOUN types can have the following informational bits set
#define NOUNCVTVALIDCT  ((I)1L<<SYMBX)     // Flag for jtcvt arg only: if set, convert only the #atoms given in the parameter   Aliases with SYMB
#define SPARSEX 31  // NOTE this extends to the sign bit
#define SPARSE            (-((I)1L<<SPARSEX))       /* P  sparse boxed                 */
// ** NAME type can have the following information flags set
#define NAMEBYVALUEX    MARKX     // set if the name is one of x x. m m. etc that is always passed by value, never by name
#define NAMEBYVALUE     ((I)1L<<NAMEBYVALUEX)     // set if the name is one of x x. m m. etc that is always passed by value, never by name
#define NAMEABANDONX SYMBX
#define NAMEABANDON            ((I)1L<<NAMEABANDONX)     // name is name::, which will be deassigned after the value is stacked.  NAMEBYVALUE must also be set
// in the parser VERB is set in a NAME type to indicate use of global symbol table
// ** BOX type can have the following informational flags set
#define BOXMULTIASSIGN  ((I)1L<<MARKX)     // set for the target of a direct multiple assignment (i. e. 'x y' =.), which is stored as a boxed list whose contents are NAMEs    aliases with MARK
// Restriction: CONW must be reserved for use as ASGNTONAME because of how parser tests for it
// Restriction: MARK must be reserved for use as BOXMULTIASSIGN because of how parser tests for it
// ** NOTE!! bits 28-30 are used in the call to cvt() (arg only) to override the convsion type for XNUMs
#define XCVTXNUMORIDEX  LPARX   // in cvt(), indicates that forced precision for result is present
#define XCVTXNUMORIDE   ((I)1<<XCVTXNUMORIDEX)   // in cvt(), indicates that forced precision for result is present
#define XCVTXNUMCVX     CONJX
#define XCVTXNUMCV      ((I)3<<XCVTXNUMCVX)  // in cvt(), the precision for xnum (if XCVTXNUMORIDE is set)


#define ANY             -1L
#define NUMERIC         (B01+INT+FL+CMPX+XNUM+RAT)
#define DIRECT          ((LIT+C2T+C4T+B01+INT+FL+CMPX+SBT)|SPARSE)  // AND must be >0
#define JCHAR           (LIT+C2T+C4T)
#define NOUN            (NUMERIC+JCHAR+BOX+SBT)
#define FUNC            (VERB+ADV+CONJ)
#define RHS             (NOUN+FUNC)
#define IS1BYTE         (B01+LIT)
#define LAST0           (B01+LIT+C2T+C4T+NAME)
#define SPARSABLE       (B01+INT+FL+CMPX+LIT)  // types that can be made sparse
// Don't traverse for ra/fa unless one of these bits is set
#define TRAVERSIBLE     (BOX|VERB|ADV|CONJ|RAT|XNUM|NAME|SYMB|SPARSE)
// Allow recursive usecount in one of these types
#define RECURSIBLE      (BOX|VERB|ADV|CONJ|RAT|XNUM|NAME|SYMB)  // sparse box not allowed
// SYMB is TRAVERSIBLE so that fa() will call to free the symbols, and RECURSIBLE so that fanapop will pass the type-flag.  To ensure that a SYMB is always freed when
// its count goes to 0, we must ensure that it is always born recursive
#define RECURSIBLENOUN  (RECURSIBLE&NOUN)
#define SGN1IFSPARSETYPE(t,dt) ((t)&-((t)&(dt)))  // sign 1 if t is sparse and one of dt
#define SGN0IFDENSETYPE(t,dt) ((t)|(((t)&(dt))-1))  // sign 0 if t is dense and one of dt
#define ISDENSETYPE(t,dt) (((t)&SPARSE+(dt))>0)  // true if t is dense and one of dt
#define SGNIFSPARSE(t)  (t)  // set sign bit if t is sparse
#define ISSPARSE(t)     ((t)<0)  // true if sparse
#define SGNIFDENSE(t)   (~(t))  // set sign bit if t is dense
#define ISDENSE(t)      ((t)>=0)  // true if dense
// Modifiers that operate on subarrays do so with virtual blocks, and those blocks may be marked as inplaceable if the backing block is inplaceable.
// The inplaceability applies to the data area, but not necessarily to the block header: if UNINCORPORABLE is set, the header must not be modified (we clone the header in that case)
// For speedy singletons, there is the additional problem that the operation expects always to write a FL value to the result area, which is OK for any
// real block but not for an inplaced virtual block, whose virtual data may be shorter than a FL.  The pure solution would be for the singleton code
// to refrain from modifying a virtual block that is shorter than a FL, but that means we would have to test for it for every arithmetic operation.  Thus
// we take the alternative, which is to not mark a virtual block inplaceable if it is a type shorter than a FL.
//
// BOX type would be OK, as singleton code doesn't touch it and all usecounts are held in the backer, except for the possibility that the backer is recursive and the virtual block isn't.
// Places that check TYPEVIPOK make an exception when the block is going to be processed by each or each2, because those routines are guaranteed not to disturb the boxes, but only
// the first level of contents, and that only when the block is pristine.
//
// Note: arithmetic dyads on bytes have similar issues, because the 8-byte-at-a-time operations may execute outside the cell of the array.  We detect
// those cases inside the atomic-dyad code in va2.c.
#define TYPEVIPOK       (FL+CMPX+SBT+(SZI==SZD?INT:0))  // sparse is never inplaceable
#define TYPESEQ(x,y)    ((x)==(y))  // types are equal
#define TYPESXOR(x,y)    ((x)^(y))  // types are not equal using full-word logical
#define TYPESNE(x,y)    ((x)!=(y))  // types are not equal
#define TYPESLT(x,y)    ((UI)(x)<(UI)(y))  // type x < type y
#define TYPESGT(x,y)    ((UI)(x)>(UI)(y)) // type x > type y

#define PARTOFSPEECHEQ(x,y) (((((x)|(RPAR&-((x)&NOUN)))^((y)|(RPAR&-((x)&NOUN))))&RPAR+CONJ+VERB+ADV)==0)  // using RPAR to hold NOUN status, verify parts-of-speech the same
#define PARTOFSPEECHEQACV(x,y) ((((x)^(y))&RPAR+CONJ+VERB+ADV)==0)  // verify known-nonnoun parts-of-speech the same

// Utility: keep the lowest 1 only
#define LOWESTBIT(x)    ((x)&-(x))

#define POSIFHOMO(s,t)  ( -(((s)^(t))&(BOX|SBT|JCHAR|MARK)) & -(((s)^(t))&(BOX|SBT|NUMERIC|MARK)) )
#define NEGIFHOMO(s,t)  ( ~POSIFHOMO(s,t) )
#define HOMO(s,t)       ( POSIFHOMO(s,t)>=0 )
#define HOMONE(s,t)     HOMO(s,t)
#define STYPE(t)        ((t)|SPARSE)
#define DTYPE(t)        ((t)&~SPARSE)

// flags in AM
#define AMNVX 0   // set if the value has been assigned to a name is used for NVR status
#define AMNV ((I)1<<AMNVX)
#define AMFREEDX 1   // set if a free for the value has been deferred & it should be freed when NVR count goes to 0
#define AMFREED ((I)1<<AMFREEDX)
#define AMIMMUTX 2   // set if the block has been marked immutable and cannot be inplaced
#define AMIMMUT ((I)1<<AMIMMUTX)
#define AMNVRCTX 3  // start of NVR count: the number of times this value is on the NVR stack
#define AMNVRCT ((I)1<<AMNVRCTX)

// Flags in the count field of type A
#define ACINPLACEX      (BW-1)
#define ACINPLACE       ((I)((UI)1<<ACINPLACEX))  // set when this block CAN be used in inplace operations.  Always the sign bit.
#define ACPERMANENTX    (BW-2)
#define ACPERMANENT     ((I)1<<ACPERMANENTX)  // next-to-top bit, set in blocks that should never modify the AC field
#define ACUSECOUNT      (I)1  // lower bits used for usecount
#define ACAND(a,v)      AC(a)&=(v);
#define ACOR(a,v)       AC(a)|=(v);
#define ACIPYES(a)      ACOR(a,ACINPLACE)
#define ACIPISOK(a)     (AC(a)<1)  // OK to modify if INPLACE set - set only when usecount=1
#define ACUC(a)         (AC(a)&(~ACINPLACE))  // just the usecount portion
#define ACUC1           (ACUSECOUNT*1) // <= this is usecount==1; > is UC>1
#define ACINCRLOCAL(a)       if(likely(!ACISPERM(AC(a))))(AC(a)=(AC(a)+1)&~ACINPLACE)
#define ACDECRLOCAL(a)       if(likely(!ACISPERM(AC(a))))(AC(a)=(AC(a)-1))
#define ACIPNO(a)       ACAND(a,~ACINPLACE)
#define ACINCR(a)       ACINCRLOCAL(a)
#define ACDECR(a)       ACDECRLOCAL(a)
#define ACINIT(a,v)     AC(a)=(v);  // used when it is known that a has just been allocated & is not shared
#define ACRESET(a,v)    AC(a)=(v);  // used when it is known that a is not shared (perhaps it's UNINCORPABLE)
#define ACSET(a,v)      AC(a)=(v);  // used when a might be shared, but atomic not needed
#define ACFAUX(a,v)     AC(a)=(v);  // used when a is known to be a faux block
#define ACINITZAP(a)    {*AZAPLOC(a)=0; ACINIT(a,ACUC1)}  // effect ra() immediately after allocation, by zapping
#define ACINITZAPRECUR(a,t) {*AZAPLOC(a)=0; ACINIT(a,ACUC1); AFLAG(a)|=(t)&RECURSIBLE;}  // effect ra() immediately after allocation, by zapping, and make the block recursive if possible
#define ACZAPRA(x)      {if(likely(AC(x)<0)){*AZAPLOC(x)=0; ACIPNO(x);}else ra(x);}
#define ACX(a)          {AC(a)=ACPERMANENT; AFLAG(a)|=AT(a)&RECURSIBLE;}
#define ACISPERM(c)     ((I)((UI)(c)+(UI)(c))<0)  // is PERMANENT bit set?
#define SGNIFPRISTINABLE(c) ((c)+ACPERMANENT)  // sign is set if this block is OK in a PRISTINE boxed noun
// same, but s is an expression that is neg if it's OK to inplace
#define ASGNINPLACESGN(s,w)  (((s)&AC(w))<0 || jt->asginfo.zombieval==w&&((s)<0)&&(!(AM(w)&(-(AM(w)&AMNV)<<AMNVRCTX))||notonupperstack(w)))  // OK to inplace ordinary operation
#define ASGNINPLACESGNNJA(s,w)  ASGNINPLACESGN(s,w)  // OK to inplace ordinary operation
// define virtreqd and set it to 0 to start
// This is used in apip.  We must ALWAYS allow inplacing for NJA types, but for ordinary inplacing we don't bother if the number of atoms of w pushes a over a power-of-2 boundary
#define EXTENDINPLACENJA(a,w)  ( ((AC(a)&(((AN(a)+AN(w))^AN(a))-AN(a)))<0) || /* inplaceable value that will probably fit */ \
  ( (((((AN(a)+AN(w))^AN(a))-AN(a))|SGNIF(AFLAG(a),AFNJAX))<0) &&  /* value will probably fit OR is NJA */\
    (jt->asginfo.zombieval==a || (!jt->asginfo.assignsym&&AC(a)==1&&(virtreqd=1,!(AFLAG(a)&(AFRO|AFVIRTUAL))))) && /* asg-in-place or virt extension */ \
    (virtreqd||!(AM(a)&(-(AM(a)&AMNV)<<AMNVRCTX))||notonupperstack(a)) )   /* name not already on stack (not required for virt extension) */ \
  )  // OK to inplace ordinary operation

/* Values for AFLAG(x) field of type A                                     */
// the flags defined here must be mutually exclusive with TRAVERSIBLE

#define AFRO            (I)1            /* read only; can't change data    */
#define AFROX           0            /* read only; can't change data    */
#define AFNJAX          1            /* non-J alloc; i.e. mem mapped    */
#define AFNJA           ((I)1<<AFNJAX)
#define AFDEBUGRESULTX  2           // special flag for values that alter debug state
#define AFDEBUGRESULT   ((I)1<<AFDEBUGRESULTX)
// Note: bit 4 is LABANDONED which is merged here
// Note: bits 8-9 are used to hold AM flags merged in symbis
#define AFNVRFLAGX      8
// the spacing of VIRTUALBOXED->UNIFORMITEMS must match ZZFLAGWILLBEOPENED->ZZCOUNTITEMS
#define AFUNIFORMITEMSX MARKX     // matches MARK
#define AFUNIFORMITEMS  ((I)1<<AFUNIFORMITEMSX)  // It is known that this boxed array has contents whose items are of uniform shape and type; the total number of those items is in AS[0]
#define AFVIRTUALX      C2TX      // matches C2TX
#define AFVIRTUAL       ((I)1<<AFVIRTUALX)  // this block is a VIRTUAL block: a subsequence of another block.  The data pointer points to the actual data, and the
                                 // m field points to the start of the block containing the actual data.  A VIRTUAL block cannot be incorporated into another block, and it
                                 // cannot be assigned, unless it is 'realized' by creating another block and copying the data.  We realize whenever we call ra() on the block,
                                 // except during the EPILOG, where we don't realize the block unless the real block is about to be freed.  Like PERMANENT blocks,
                                 // VIRTUAL blocks are always recursive so that fa() will not recur.  Virtual blocks are always freed from tpop.  Since it cannot be copied or realized,
                                 // the virtual block always has usecount of ACUC1 or ACUC1+ACINPLACE.  EXCEPTION: for the initial assignment to x/y in an explicit
                                 // definition, we allow assigning a virtual block, because we know that the block and its backer are allocated in a higher level
                                 // and can never be freed until the explicit definition finishes.  In this case it is safe to increment the usecount of the virtual block -
                                 // not to ra() the block, which would try to recur.  It is OK to fa() the block on exit or on reassignment, because that will
                                 // just decrement the usecount of the nonrecursive block.
                                 // VIRTUAL blocks are normally not inplaceable (since they are by definition aliased to another block), but the temporary
                                 // UNINCORPORABLE blocks created by partitioning modifers to track cells may be inplaceable, and a virtual block whose backer
                                 // has been abandoned may be marked inplaceable as well.
                                 // NOTE: AFVIRTUALX must be higher than any RECURSIBLENOUN type (for test in result.h)
#define AFUNINCORPABLEX SBTX      // matches SBTX
#define AFUNINCORPABLE  ((I)1<<AFUNINCORPABLEX)  // (used in result.h) this block is a virtual block used for subarray tracking and must not
                                // ever be put into a boxed array, even if WILLBEOPENED is set, because it changes
#define AFVIRTUALBOXEDX XDX   // matches XDX
#define AFVIRTUALBOXED  ((I)1<<AFVIRTUALBOXEDX)  // this block (created in result.h) is an array that is about to be opened, and thus may contain virtual blocks as elements
#define AFPRISTINEX      ASGNX  // matches ASGN
#define AFPRISTINE  ((I)1<<AFPRISTINEX)  // meaningful only for BOX type.  This block's contents were made entirely of DIRECT inplaceable or PERMANENT values, and thus can be
   // inplaced by &.> .  If any of the contents are taken out, the PRISTINE flag must be cleared, unless the block is never going to be used again (i. e. is inplaceable).
   // When a VIRTUAL block is created, it inherits the PRISTINE status of its backer; if the block is modified or a value escapes by address, PRISTINE status is cleared in the backer.
   // If a PRISTINE virtual block is realized, the backer must become non-PRISTINE (because its contents are escaping).
   // If a PRISTINE block is incorporated, it must lose PRISTINE status because it is no longer possible to know whether contents may have been fetched while the
   // block was incorporated.
#define AFDPARENX CONWX     // matches CONW
#define AFDPAREN  ((I)1<<AFDPARENX)  // In the words of an external definition, this word came from (( )) and must use linear rep for its display
   // MUST BE GREATER THAN ANY DIRECT FLAG (not including the SPARSE flag)
#define AFUPPERTRIX RPARX      // matches RPAR
#define AFUPPERTRI  ((I)1<<AFUPPERTRIX)  // (used in cip.c) This is an upper-triangular matrix
// NOTE: bit 28 (LPAR) is used to check for freed bufs in DEADARG

#define AFAUDITUCX      32   // this & above is used for auditing the stack (you must run stack audits on a 64-bit system)
#define AFAUDITUC       ((I)1<<AFAUDITUCX)    // this field is used for auditing the tstack, holds the number of deletes implied on the stack for the block
#define AFLAGINIT(a,v)  AFLAG(a)=(v);  // used when it is known that a has just been allocated & is not shared
#define AFLAGRESET(a,v) AFLAG(a)=(v);  // used when it is known that a is not shared (perhaps it's UNINCORPABLE)
#define AFLAGSET(a,v)   AFLAG(a)=(v);  // used when a might be shared and this must be atomic
#define AFLAGFAUX(a,v)  AFLAG(a)=(v);  // used when a is known to be a faux block
#define AFLAGANDLOCAL(a,v)   AFLAG(a)&=(v);  // LOCAL functions are used when the block is known not to be shared
#define AFLAGORLOCAL(a,v)    AFLAG(a)|=(v);
#define AFLAGAND(a,v)   AFLAG(a)&=(v);
#define AFLAGOR(a,v)    AFLAG(a)|=(v);
#define AFLAGPRISTNO(a) AFLAGANDLOCAL(a,~AFPRISTINE)  // nothing from another thread can be PRISTINE
// following used to modify AM as NVR count
#define AMNVRINCR(a) AM(a)+=AMNVRCT;  // increment, no return
#define AMNVRDECR(a,am) (am=AM(a),AM(a)-=AMNVRCT,am)  // save count, decrement, return old value
#define AMNVRSET(a,x) (AM(a)=(x))
#define AMNVRAND(a,x) (AM(a)&=(x));  // AND, no return
#define AMNVROR(a,x) (AM(a)|=(x));  // OR, no return
// decide action and new AM value to free a
// nvrct!=0, !free -> set free
// nvrct!=0, free -> no chg, fa
// nvrct==0, final -> no chg, fa
// nvrct==0, !final, free -> (disaster about to happen, someone else is freeing the block we are about to use)
// nvrct==0, !final, !free -> stack, incr nvrct, set free
// v==nv if all we have to do is fa
// old value of AM is loaded into v.  nv is a temp.  final is an expression whose value is 1 iff this is a final assignment, else 0
#define AMNVRFREEACT(a,final,v,nv) (v=AM(a),nv=v|AMFREED,nv=v&-AMNVRCT?nv:1*AMNVRCT+AMFREED+AMNV,nv=v<((final)<<AMNVRCTX)?v:nv,AM(a)=nv);
#define AMNVRCINI(a) {if(!(AM(a)&AMNV))AMNVRSET(a,AMNV);}  // if AM doesn't have NVR semantics, initialize it

// Flags in the AR field of symbol tables
#define ARNAMED 1   // set in the rank of a named locale table.  This bit is passed in the return from jtsyrd1
#define ARNAMEADDEDX LPERMANENTX  // 2 Set in rank when a new name is added to the local symbol table.  We transfer the bit from the L flags to the rank-flag
#define ARNAMEADDED (1LL<<ARNAMEADDEDX)
#define ARLCLONEDX NMSHAREDX  // 4 set if this is a cloned local symbol table (in which symbol numbers are invalid)
#define ARLCLONED (1LL<<ARLCLONEDX)  // set if this is a cloned local symbol table (in which symbol numbers are invalid)
#define ARLOCALTABLE 16  // Set in rank of all local symbol tables.  This indicates that the first hashchain holds x/y info and should not be freed as a symbol
#define ARLSYMINUSE 32  // This bit is set in the rank of the original symbol table when it is in use

#define SFNSIMPLEONLY 1   // to sfn: return simple name only, discarding any locative

#define FIXALOCSONLYLOWEST 4  // to fixa: replace only the first occurrence of u/v in each branch
#define FIXALOCSONLY 8  // to fixa: replace only u/v (IMPLOC)
#define FIXASTOPATINV 16  // to fixa: stop afixing a branch when it gets to a an explicit obverse

// AH field of all blocks
#define AFHRH(a) ((a)->h)    // the workarea


typedef struct {  // we could consider align(4) to save space - would require change to bpnonnoun 
 union{
  struct {
   C type;  // control-word number from w.h
   C canend;  // Indicates that the most-recent B-block result can (1) or can't (2) become the result of the running definition.  0 means we don't know yet.
   US sentn;    // number of tokens in the sentence
   I4 sentx;   // index of the start of the sentence in the sequential list of tokens for the definition
  } indiv;  // individual fields
  UI group[2-SY_64];  // fields all in one or two words
 } ig;
 US go;  // line number.  Depends on type; can be loop-to point, failing-branch point, or error handler
 US source;  // source line number
} CW;

/* control word (always has corresponding token string)                             */
/* type   - as specified in w.h                                            */
/* go     - line number to go to                                           */
/* source - source line number                                             */
/* i      - beginning index of token string                                */
/* n      - length          of token string                                */
// canend - Indicates that the most-recent B-block result can (1) or can't (2) become the result of the running definition.  0 means we don't know yet.


#define DCPARSE  1      /* sentence for parser                                          */
#define DCSCRIPT 2      /* script              -- line()                                */
#define DCCALL   3      /* verb/adv/conj call  -- dbunquote()                           */
#define DCJUNK   4      /* stack entry is stale                                      */

typedef struct DS{      /* 1 2 3                                                        */
 struct DS*dclnk;       /* x x x  link to next stack entry                              */
 A dcy;                 /* x x x  &tokens; text       ; right argument                  */
 I dcn;                 /* x x x  #tokens; line #     ; ptr to symb entry               */
 I dcix;                // x x x  index ; next index  ; line# in exp def being executed, or to be exec next
 I dcj;                 /* x x x  error#; prev index  ; error #                         */
 C dctype;              /* x x x  type of entry (see #define DC*)                       */
 B dcsusp;              /* x   x  1 iff begins a debug suspension                       */
 C dcss;                //   x x  1 if script is supplying sentences (0 if interrupted by prompt) ;single step code
 C dcnewlineno;         //     x  set when debug has installed a new line number into dcix
 C dcpflags;            //   x    prompt flags, see JTPRTYO
 C dcredef;             //     x  set if this definition has been reassigned while running on top of stack
 A dca;                 /*     x  fn/op name                                            */
 A dcf;                 /*     x  fn/op                                                 */
 A dcx;                 /*     x  left argument                                         */
 A dcloc;               /*     x  local symb table (0 if not explicit)                  */
 A dcc;                 /*     x  control matrix   (0 if not explicit)                  */
 I dcm;                 /*   x x        ; script index; # of non-locale part of name    */
 I dcstop;              /*     x  the last stop in this function                        */
} DST;

typedef DST* DC;


typedef struct {I e,p;X x;} DX;
                                /* for the p field in DX */
#define DXIPREC         ((I)-1) /* infinite precision    */
#define DXINF           ((I)-2) /* _  infinity           */
#define DXMINF          ((I)-3) /* __ negative infinity  */

/* extended floating point                                                 */
/* e - exponent                                                            */
/* p - precision & other codes                                             */
/*        +ve   # of significant digits                                    */
/*        _1    infinite precision (with trailing 0s)                      */
/*        _2    infinity _                                                 */
/*        _3    negative infinity __                                       */
/* x - mantissa                                                            */
/*        least significant digit first                                    */
/*        decimal point after last digit                                   */

// LSB codes in enqueued words.  Set by enqueue(), used by parsea().  Means that all boxes must be aligned to cacheline boundaries and freeing boxes must ignore these flags
// type of 0000 is unused; 1-11 are the type bits in order
#define QCMASK 0x1fLL   // all the LSB flags
#define QCWORD(x) ((A)((I)(x)&~QCMASK))  // the word pointer part of the QC
#define QCTYPE(x) ((I)(x)&QCMASK)  // the type-code part
#define QCINSTALLTYPE(x,t) ((A)((I)(x)|(I)(t)))  // install t into word-pointer x
// the CAVN types are selected for comp ease in the typeval field of an assigned value, which might also hold VALTYPENAMELESSADV
#define QCNOUN ((LASTNOUNX-LASTNOUNX)+1)  // this bit must not be set in any other CAVN type
#define QCADV  ((ADVX-LASTNOUNX)+1) // 4
// note: code point 5 must be left unused so we don't mess up clearing the pull queue
#define QCVERB  ((VERBX-LASTNOUNX)+1)  // 8
#define QCLPAR  ((LPARX-LASTNOUNX)+1)  // 9
#define QCCONJ  ((CONJX-LASTNOUNX)+1)  // 10
#define QCNAMEASSIGNED ((NAMEX-LASTNOUNX)+1) // name followed by copula
// the last AT type is RPAR, which is 11 (30-20+1)
// assignments occupy 12-15, with 4 variants
#define QCASGN 0x0c // copula.  QCASGNISLOCAL and QCASGNISTONAME are modifiers
#define QCASGNISLOCAL 0x1 // =. preceded by nonlocative name
#define QCASGNISTONAME 0x2  // copula is preceded by name
#define QCISLKPNAME 0x10LL   // name requires lookup (i. e. not assigned)
#define QCNAMEBYVALUE 0x01   // combining flag - name is mnuvxy type
#define QCNAMEABANDON 0x08 // combining flag - name has :: - set only if not assigned


#define SYMLINFO 0  // index of LINFO entry
#define SYMLINFOSIZE 1     // Number of symbol-table entries that DO NOT root symbol chains, but instead are LINFO entries
// The MSB of LX values is used to indicate that the NEXT value is NOT permanent.  We do this so that we can visit all PERMANENT entries without ever
// touching a non-PERMANENT one.  By marking NON-permanent symbols with the sign bit, we allow the code for permanent symbols to assume the
// sign is 0, since the bucket #s are always for permanent symbols.  The end-of-chain pointer does not have the PERMANENT flag set
#define SYMNONPERMX 31
#define SYMNONPERM (I4)(1L<<SYMNONPERMX)   // flag set if next is non-permanent, or if an LX is invalid
#define SYMNEXT(s) ((s)&~SYMNONPERM)  // address of next symbol
#define SYMNEXTISPERM(s) ((s)>0)  // true if next symbol is permanent

typedef struct {
 A name;  // name on lhs of assignment; in LINFO, pointer to NM block.  May be 0 in zombie values (modified cached values)
 A val;  // rhs of assignment, or 0 for PERMANENT symbols that have not yet been assigned
 C flag;  // Lxx flags, see below.  Not used for LINFO (AR is used for locale flags)
 C valtype;  // if a value is set, this holds the QCxxx type for the word  0 if no value or value not CAVN
 S sn;  // script index the name was defined in.  Not used for LINFO
 LX next;  // LX of next value in chain.  0 for end-of-chain.  SYMNONPERM is set in chain field if the next-in-chain exists and is not LPERMANENT
} L;  // name must come first because of the way we use validitymask[11]

/* symbol pool entry                         LINFO entry (named/numbered)      */
//-------------------------------------------------------------------------
/* name - name on LHS of assignment          locale name                    */
/* val  - value                              locale search path              */
// flag - various flags                      locale flags                 
/* sn   - script index                              not used                   */
/* next - index of successor in hash list or 0      mot used                  */

// FOR EXECUTING LOCAL SYMBOL TABLES: AK() points to the active global symbol table, AM() points to the calling local symbol table.
// In all local symbol tables, the first 'hashchain' has the chain numbers for y/x; they are the first symbols in those chains, always permanent

#define LCH             (I)1            /* changed since last exec of 4!:5 */
#define LPERMANENTX  1
#define LPERMANENT   ((I)1<<LPERMANENTX)  // set if the name was assigned from an abandoned value, and we DID NOT raise the usecount of the value (we will have changed INPLACE to ACUC1, though).
#define LINFO           (I)4            /* locale info                     */
#define LCACHED         (I)8      // this value is cached in some nameref
#define LWASABANDONEDX  4
#define LWASABANDONED   ((I)1<<LWASABANDONEDX)  // set if the name was assigned from an abandoned value, and we DID NOT raise the usecount of the value (we will have changed INPLACE to ACUC1, though).
                                    // when the name is reassigned or deleted, we must refrain from fa(), and if the value still has AC=ACUC1, we should revert it to inplaceable so that the parser will free it
                                    // immediately
                                    // This value passes into AFLAGS and must not overlap anything there
#define LHASNAME        (I)32      // name is nonnull - this value is not used internally; it appears in the result of 18!:31
#define LHASVALUE       (I)64     // value is nonnull - this value is not used internally; it appears in the result of 18!:31
#define LREADONLY       (I)128   // symbol cannot be reassigned (it is xxx or xxx_index)
// in LINFO entry
#define LMOD            (I)1          // table has had new entries added (used for local symbol tables only)

// in valtype
#define ATYPETOVALTYPE(t) (((t)&NOUN)?1:CTTZI((t)>>(LASTNOUNX-1)))  // types 1=NOUN 4=ADV 8=VERB 10=CONJ  0 means 'no value'
#define VALTYPETOATYPE(t) ((1LL<<(LASTNOUNX-1))<<(t))  // convert t from valtype form to AT form (suitable only for conversion to pt - actual noun type is lost)
#define VALTYPENAMELESSADV 0x0eLL  // set in nameless & non-locative adv, to suppress reference creation.  Would like to make this a unique bit for test

// In Global symbol tables (including numbered) AK is LOCPATH, and AM is LOCBLOOM
// The first L block in a symbol table is used to point to the locale-name rather than hash chains
#define LOCNAME(g) ((JT(jt,sympv))[LXAV0(g)[SYMLINFO]].name)
#define LOCTHREAD(g)  ((JT(jt,sympv))[LXAV0(g)[SYMLINFO]].next)
#define LOCPATH(g) (g)->kchain.locpath
#define LOCBLOOM(x) AM(x)
#define BLOOMOR(x,v) {LOCBLOOM(x)|=(v);}  // or a new value into the Bloom filter


// Definition of callstack

typedef struct {
 I type;  // type of entry, flagged per below
 void *value;  // locale or name, depending on the type
} LS;
#define CALLSTACKPOPLOCALE 2  // value is jt->global that must be restored after function returns
#define CALLSTACKPOPFROM 4  // value is jt->global that must be modified in the caller of this function also
#define CALLSTACKCHANGELOCALE 8  // value is jt->global that was changed within execution of this name
#define CALLSTACKPOPLOCALEFIRST 16  // set in the POPLOCALE that is added when the first POPFROM is seen
#define CALLSTACKPUSHLOCALSYMS 32  // value is jt->locsyms that must be restored
#define CALLSTACKDELETE 256  // the given locale must be deleted, and this is the earliest place on the stack that refers to it

// Add an entry to the call stack, and increment the index variable
#define pushcallstack(i,t,v) (jt->callstack[i].type=(t), jt->callstack[i].value=(v), ++i)
#define pushcallstack1(t,v) {ASSERT(jt->callstacknext<jt->fcalln,EVSTACK);  pushcallstack(jt->callstacknext,(t),(v));}
#define pushcallstack1d(t,v) {FDEPDEC(d); ASSERT(jt->callstacknext<jt->fcalln,EVSTACK);  pushcallstack(jt->callstacknext,(t),(v));}

// NM struct: pointed to by the name field of a symbol, and used for lookups.  Names are allocated with rank 1 (??)
typedef struct{
 I bucketx; // (for local simple names, only if bucket!=0) the number of chain entries to discard before
//   starting name search.  If negative, use one's complement and do not bother with name search - symbol-table entry
//   is guaranteed to be at that position
//   (for direct locatives) the hash of the locative - if numbered, the number itself.
//   (for indirect locatives) hash of the last indirect name
//   (for locale names in SYMLINFO of a numbered locale) the locale number
 A cachedref; // (only for cachable NAME blocks): the nameref for this name entry, if it is not a noun.  The cached ref may or may not have the LX of the symbol for the name
//         if flag&NMCACHEDSYM is set, the value here is the index of a symbol with the value to use for the name - it could be from a NAMELESS modifier
 union {
  UI symxbucket;  // two fields fetched together
  struct {
   LX symx;  // (only for SHARED names, which are only local variables and never cachable) the index of the symbol allocated in the primary symbol table
   I4 bucket; // (for local simple names) the index of the hash chain for this symbol when viewed as a local
  } sb;
 } sb;
//   0 if chain index not known or name is a locative
 UI4 hash;  // hash for non-locale part of name
 UC m; // length of non-locale part of name note 255-byte limit! (AN holds the length of the entire name including the locative)
 C flag, // string part of full name (1 to ?? characters, including locale of assignment if given)
 s[1];  // up to 24 chars fit in a 128B allo
} NM;

// values in flag:
#define NMLOC           1       // direct   locale abc_lm_   only one of NMLOC/NMILOC/NMIMPLOC is set
#define NMSHAREDX    2
#define NMSHARED     (1LL<<NMSHAREDX)      // This NM is for a locally-defined name and is shared by all references to the name
#define NMILOC          2       // indirect locale abc__de__fgh ...     only one of NMLOC/NMILOC/NMIMPLOC is set
#define NMDOT           128       // one of the names m. n. u. v. x. y.      */
#define NMXY            8       // x/y, which must have NAMEBYVALUE set
#define NMIMPLOC        16      // this NM block is u./v.     only one of NMLOC/NMILOC/NMIMPLOC is set
#define NMCACHEDX       5
#define NMCACHED        (1LL<<NMCACHEDX)      // This NM is to cache any valid lookup
#define NMCACHEDSYMX    6
#define NMCACHEDSYM     (1<<NMCACHEDSYMX)      // This NM is storing a symbol index, not a pointer to a reference


typedef struct {I a,e,i,x;} P;

/* value fields of sparse array types                                      */
/* fields are offsets from beginning of the P struct                       */
/* a: sparse axes                                                          */
/* e: sparse element                                                       */
/* i: index matrix, columns correspond to a                                */
/* x: value cells corresponding to rows of i                               */

#define SPA(p,a)        ((A)((p)->a+(C*)(p)))  // a is one of aeix; result is A pointer for that component
#define SPBV(p,a,v,x)      {RZ(v = (x)); INCORP(v); (p)->a=(C*)v-(C*)(p);}  // store x into component (a); return if x is 0.  a is one of aeix.  Result in v
#define SPB(p,ZWa,x)      {A ZWo = (x); SPBV((p),ZWa,ZWo,(x))}  // store x into component (a); return if x is 0.  a is one of aeix

// Header for hashtables used in i.
// This sits at the beginning of the allocated block, holding info about the stored values
typedef struct {
 I datasize;   // number of bytes in the data area
 I hashelelgsize;  // lg(size of a hashed element)
 UI currentlo;   // the lowest position in the hashtable of the current allocation.
 UI currenthi;   // the highest position+1 of the current allocation.
 UI currentindexofst;   // the value in the hashtable that the minimum value in the input will map to
 UI currentindexend;    // the highest value that can possibly be written, +1
 UI previousindexend;  // All positions from 0 to currenthi are known to be less than currentindexend.
             // Positions from currenthi to the end are known to be less than previousindexend.
 UI invalidlo;   // the start of the area that does not have constrained values because it was used for a bit table (as an index into hashtable, rounded up to multiple of I for endian reasons)
 UI invalidhi;   // the end+1 of the area used for a bit table  (as an index into hash table, rounded up to multiple of I)
 I datamin;  // (for small-range use) minimum value in the data
 UI datarange;  // (for small-range use) range+1 of the data
 D cct;  // if this is tolerant, the cct used to build the table
 // 12 words here; 7 words of header (we allocate no shape);  so this block is 19 words after the
 // memory allocation; add one fill to get on the same 256-bit boundary as the allocation.
 I filler;
 union {   // We index into the data with varying strides, depending on the range of the data
  UC UC[1];  // cannot have union of empty vectors
  US US[1];
  UI4 UI4[1];
  UI UI[1];
 } data;
} IH;
#define IHAV(x)         ((IH*)((C*)(x)+AK(x)))  //  how to refer to the header area

// Return value from condrange
typedef struct {
 I min;  // smallest value found
 I range;  // max+1-min, or 0 if range exceeds max given
} CR;

/* performance monitoring stuff */

typedef struct{
 A name;                /* verb/adverb/conjunction name                    */
 A loc;                 /* locale name                                     */
 I lc;                  /* line number (-1 for entry; -2 for exit)         */
 I s;                   /* space                                           */
 I t[2];                /* time                                            */
 C val;                 /* valence: 1 or 2                                 */
 C unused[3];           /* padding                                         */
} PM;

#define PMCOL  6        /* # of fields in PM                               */

typedef struct{
 I n;                   /* maximum number of records                       */
 I i;                   /* index of next record to be written              */
 I s;                   /* initial bytesmax value                          */
 I pmctr;               // counter, set > 0 to start sampling
 B rec;                 /* what to record (0 entry & exit; 1 all)          */
 B trunc;               /* what to do on overflow (0 wrap; 1 truncate)     */
 B wrapped;             /* 1 iff wrapping has happened                     */
 C unused[1];           /* padding                                         */
} PM0;


/* each unique symbol has a row in JT(jt,sbu)                                 */
/* a row is interpreted per SBU                                            */
/* for best results make sizeof(SBU) a multiple of sizeof(I)               */
 
typedef struct{
 I  i;                  /* index into sbs                                  */
 I  n;                  /* length                                          */
 UI h;                  /* hash value                                      */
 I  color;              /* binary tree: color                              */
 I  parent;             /* binary tree: index of parent                    */
 I  left;               /* binary tree: index of left  child               */
 I  right;              /* binary tree: index of right child               */
 I  order;              /* order number                                    */
 I  down;               /* predecessor in ordering                         */
 I  up;                 /* successor   in ordering                         */
 I  flag;               /* bit flags                                       */
} SBU;

#define SBC2  1         /* 1 iff 2-byte character                          */
#define SBC4  2         /* 2 iff 4-byte character                          */

// Info for calling an atomic verb
typedef struct {VF f;I cv;} VA2;  // for dyads
typedef struct {VA1F f;I cv;} VA1;  // for monads
typedef struct {VARPSF f;I cv;} VARPS;  // for reduce/prefix/suffix

typedef struct {I nprec; VARPS actrtns[];} VARPSA;
typedef struct {VA2 p2[13];VARPSA *rps;} VA;
typedef struct {VA1 p1[6];} UA;

typedef struct {
 // the localuse fields are not freed or counted for space, as the f/g/h fields are.  They are for local optimizations only.
 union {
  // start with the larger localuse, which requires a second cacheline.  This is 16 bytes, the first 8 of which are in the excess (first) cacheline
  I4 clr[4];   // used to init to 0 - extends the union for 32-bit
  struct {AF func; I parm;} boxcut0;  // for x <;.0 y  and  x (<;.0~ -~/"2)~ y, .parm is ~0 for first, 0 for second, and .func points to failover routine (seldom used).  func in first cacheline
  I4 srank[4];   // for RANK conj, the signed ranks - extends the union in 32-bit
  // the rest do not require both cachelines in 64-bit
  struct {
   union {
    I filler;  // pad to cacheline
   } lu0;
   // end of first cacheline, which is not used much during execution
   union {  // 8 bytes in the second (main) cacheline
    D cct;  // for comparison tolerance, FIT conj  =!.n OR comparison combination (i.&1@:(e.[!.n])) OR [e. i. ([-.-.)]&n OR m&i[.:] the CCT, 0 for default (never in an actual prehash).  For 32-bit, this extends the union, but that's OK since it doesn't add a cacheline.
    struct {
     I4 cgerx; // For cyclic iterators, the index of the next gerund to execute.  Here to avoid conflict with cut
     I4 cutn;  // for u;.n where n is nonzero, n.  u/. also goes through this code.  There could be cyclic iterators but not boxcut
    } gercut;
    VARPSA *redfn;  // for reductions (u/ u/\ u/\.) address of rps block (may be dummy block)
    US uavandx[2];   // offset from start of va/va1tbl to VA/UA block for adocv [monad then dyad]
    AF foldfn;  // for Fold final operator, pointer to the dyadic EP of the handler (xdefn or unquote)
    A wvb;  // for u&.[:]v, the verb whose inverse is needed
    I linkvb;  // for dyads ; (,<) ,&[:]<  indicates which function
    LX cachedref;  //  for namerefs ('name'~), 0 if non-cachable, neg if cachable but not yet cached, positive if cached
    AF fork2hfn;   // for dyad fork that is NOT a comparison combination or jtintersect, the function to call to process h (might be in h@][)
   } lu1;  // this is the high-use stuff in the second cacheline
  };
 } localuse;  // always 16 bytes, 4 I4s
 AF valencefns[2];   // function to call for monad,dayd
 A fgh[3];  // operands of modifiers.  h is used for forks and also as a storage spot for parms.  all 3 are freed when the V block is freed
 I4 flag;
 UI4 flag2;
 RANK2T lrr;  // combining dyad ranks: (left<<RANKTX)|right
 RANKT mr;  // combining monad rank
 C id;  // pseudochar for the function encoded here
 C lc;  // lc is a local-use byte.  Used in atomic verbs to indicate which singleton function to execute.  in the derived function from fold, lc has the original id byte of the fold op
} V;  // two cachelines exactly in 64-bit (16 Is); 20 I4s in 32-bit
// The AN and AR fields of functions are not used


#define ID(f)  FAV(AT(f?f:FUNCTYPE0)&FUNC?f:FUNCID0)->id  // can be branchless, if compiler can manage it
#define VFLAGNONE 0L
#define VRTNNONE ((A)0)
  
                                        /* type V flag values              */
// bits 0-6 are used in comparison compounds to encode the type of compound, see vcompsc.c
// They must have this setting when the verb is fit u!.n or -. ([ -. -.) i. i: e. or a comparison compound
// They are examined during u&n and m&v processing.  Bits 0-2 are the comparison type, bit 3-5 are the action type.
// NOTE: comparison type e. is type 7.  If u&n sees bits 0-2=111 in u, it will generate a hashtable.  To prevent this from
// happening incorrectly, leave bit 2=0.
#define VFCOMPCOMP      0xff  // flag bits for comparison compounds, also used for other purposes
// NOTE: comparison flags pun with VFATOP[RL] in (comp i[.:] [01]:) but that's OK because the constant verbs don't inplace thus they ignore the punned flags
// for other types, they are defined as follows:
#define VFATOPL         JTINPLACEW     // (in execution of forks and v0`v1`v2) f/v0 is x@[, so OK to inplace w arg of h
#define VFATOPR         JTINPLACEA     // (in execution of forks and v0`v1`v2) f/v0 is x@], so OK to inplace a arg of h
#define VFHKLVLDECX     0   // (in (compare L.) hooks) set for > and <: to indicate increment of x needed before levelle
#define VFHKLVLDEC      (((I)1)<<VFHKLVLDECX)
#define VFHKLVLGTX      1   // (in (compare L.) hooks) set for < and <: to indicate complement of result of levelle needed
#define VFHKLVLGT       (((I)1)<<VFHKLVLGTX)
#define VFSCANIRSX     0   // (in u/\) set if u supports IRS2
#define VFSCANIRS      (((I)1)<<VFSCANIRSX)
#define VFUNDERHASINVX  0  // (in u&.[:]v) set if h has the inverse already added
#define VFUNDERHASINV      (((I)1)<<VFUNDERHASINVX)
#define VFATOPPOLYX  0  // (in p.) the function to run after p.  0=none, 1=^
#define VFATOPPOLY      (((I)3)<<VFATOPPOLYX)
#define VFATOPPOLYNONE  0
#define VFATOPPOLYEXP  1
#define VFKEYSLASHTX  0  // (in f/.) set if f is u/ where u is one of + <. >., indicating which types are OK for atoms (can't handle int ovfl)
#define VFKEYSLASHT      (((I)(2*FL-1))<<VFKEYSLASHTX)
#define VFKEYSLASHFX  (FLX+1)  // (in f/.) function coded for, 0=<. 1=>. 2=+
#define VFKEYSLASHF      (((I)3)<<VFKEYSLASHFX)
// leave bit 2 open

// bits 8 and above are available for all verbs:
#define VGERLX          8
#define VGERL           (((I)1)<<VGERLX)          /* gerund left  argument           */
#define VGERR           (I)512          /* gerund right argument           */
// bit 10 free
#define VIRS1X          11
#define VIRS1           (I)2048         /* 11 monad has integral rank support */
#define VIRS2X          12
#define VIRS2           (((I)1)<<VIRS2X)         /* 12 dyad  has integral rank support */
#define VFLR            (I)0x2000         /* function is <.@g                */
#define VCEIL           (I)0x4000       /* function is >.@g                */
#define VMOD            (I)0x8000        /* function is m&|@g               */
#define VLOCK           (I)0x10000        /* function is locked              */
#define VNAMED          (I)0x20000       /* named explicit defn             */
#define VFIX            (I)0x40000       /* f. applied                      */
#define VXOPRX          19
#define VXOPR           ((I)1<<VXOPRX)       /* : defn with u. and x.           */
#define VXOP            (I)0x100000      /* : defn derived fn               */
#define VTRY1           (I)0x200000      /* monad contains try.             */
#define VTRY2           (I)0x400000      /* dyad  contains try.  must be just above VTRY1           */
// bits VJTFLGOK1/VJTFLGOK2/VASGSAFE are wired into a flag reg in parser
#define VJTFLGOK1X    23    // monad can handle flags in jt must be paired with VJTFLGOK2X
#define VJTFLGOK1     (((I)1)<<VJTFLGOK1X)
#define VJTFLGOK2X    24    // dyad can  handle flags in jt
#define VJTFLGOK2     (((I)1)<<VJTFLGOK2X)
#define VXOPCALL       (I)0x2000000      // 25 : defn derived fn call overlaps SYMB/ASGNLOCAL
#define VASGSAFEX     26
#define VASGSAFE      (((I)1)<<VASGSAFEX)     // does not alter locale/path
#define VDDOP           ((I)(1L<<27))     /* derived from a derived operator */
#define VISATOMIC1      ((I)(1L<<28))     // processes each atom individually (logically rank 0, but handles all ranks)
#define VISATOMIC2      ((I)(1L<<29))    // dyad is atomic.  localuse will point to the VA entry for the verb
#define VFUSEDOK2  ((I)(1L<<30))    // this block can be executed by passing in another block (containing rank) whose fgh[0] points to the native block for this primitive

// bits in flag2:
#define VF2NONE 0
// bit 0 unused
#define VF2BOXATOP1X      1   // This verb is one of  <  <@f   <@:f   <&f   <&:f    f&.>  f&.:>
#define VF2BOXATOP1     ((I)(((I)1)<<VF2BOXATOP1X))
#define VF2BOXATOP2X      2   // This verb is one of  <@f   <@:f   f&.>  f&.:>
#define VF2BOXATOP2     ((I)(((I)1)<<VF2BOXATOP2X))
// next 2 flags must be adjacent as we carry from one to the other
#define VF2WILLOPEN1PROPX  3   // If WILLBEOPENED is set in jt coming into this verb, it should be passed through to the execution of the verb producing y.  Monadic case.  Cannot be set if WILLOPEN is set.
#define VF2WILLOPEN1PROP       ((I)(((I)1)<<VF2WILLOPEN1PROPX))
// next flag must be same as JTWILLBEOPENED
#define VF2WILLOPEN1X      4   // This verb will open y as its first act.  Monad case only.  This becomes the WILLBEOPENED flag in jt
#define VF2WILLOPEN1       ((I)(((I)1)<<VF2WILLOPEN1X))
// must leave a gap for WILLBEOPENED in result.h
// 6 free
// next flag must be same as JTCOUNTITEMS
#define VF2USESITEMCOUNT1X 7   // This verb can make use of an item count stored in m.  Monad case only
#define VF2USESITEMCOUNT1  ((I)(((I)1)<<VF2USESITEMCOUNT1X))
// must leave a gap for COUNTITEMS in result.h
// next 3 flags must be spaced from VF2BOXATOP? to match spacing in ZZFLAGS
#define VF2ATOPOPEN1X     8   // This verb is one of  > @> &> &.>
#define VF2ATOPOPEN1     ((I)(((I)1)<<VF2ATOPOPEN1X))
#define VF2ATOPOPEN2WX    9   // This verb is one of  &> &.>
#define VF2ATOPOPEN2W     ((I)(((I)1)<<VF2ATOPOPEN2WX))
#define VF2ATOPOPEN2AX    10   // This verb is one of  &> &.>
#define VF2ATOPOPEN2A     ((I)(((I)1)<<VF2ATOPOPEN2AX))

#define VF2RANKATOP1X     11   // set if this verb starts out with rank loop and thus can be subsumed into a higher rank loop
#define VF2RANKATOP1     ((I)(((I)1)<<VF2RANKATOP1X)) 
#define VF2RANKATOP2X     12   // set if this verb starts out with an outer rank loop.  " @ & &. and not special-cased
#define VF2RANKATOP2     ((I)(((I)1)<<VF2RANKATOP2X))
#define VF2RANKONLY1X     13   // set if this verb is u"r, not special-cased (i. e. function points to rank processing).  The rank may be subsumed into a higher rank before we see arguments.
#define VF2RANKONLY1     ((I)(((I)1)<<VF2RANKONLY1X)) 
#define VF2RANKONLY2X     14
#define VF2RANKONLY2     ((I)(((I)1)<<VF2RANKONLY2X))
// Next 6 flags must be spaced so they can shift down to VF2WILLOPEN1PROP, WILLOPEN1, and COUNTITEMS1
#define VF2WILLOPEN2WPROPX  15   // If WILLBEOPENED is set in jt coming into this verb, it should be passed through to the execution of the verb producing y.  Dyadic case.  Cannot be set if WILLOPEN is set.
#define VF2WILLOPEN2WPROP     ((I)(((I)1)<<VF2WILLOPEN2WPROPX))
#define VF2WILLOPEN2WX      16   // This verb will open y as its first act  This becomes the WILLBEOPENED flag in jt
#define VF2WILLOPEN2W       ((I)(((I)1)<<VF2WILLOPEN2WX))
#define VF2WILLOPEN2APROPX  17   // If WILLBEOPENED is set in jt coming into this verb, it should be passed through to the execution of the verb producing x.  Dyadic case.  Cannot be set if WILLOPEN is set.
#define VF2WILLOPEN2APROP     ((I)(((I)1)<<VF2WILLOPEN2APROPX))
#define VF2WILLOPEN2AX      18   // This verb will open x as its first act.  This becomes the WILLBEOPENED flag in jt
#define VF2WILLOPEN2A       ((I)(((I)1)<<VF2WILLOPEN2AX))
#define VF2USESITEMCOUNT2WX 19   // This verb can make use of an item count stored in y.  This becomes the WILLBEOPENED flag in jt
#define VF2USESITEMCOUNT2W  ((I)(((I)1)<<VF2USESITEMCOUNT2WX))
#define VF2USESITEMCOUNT2AX 21   // This verb can make use of an item count stored in y.  This becomes the WILLBEOPENED flag in jt
#define VF2USESITEMCOUNT2A  ((I)(((I)1)<<VF2USESITEMCOUNT2AX))
#define VF2IMPLOCX 20   // This verb is one of u. v.
#define VF2IMPLOC  ((I)(((I)1)<<VF2IMPLOCX))

// layout of primitive, in the primtbl.  It is a memory header (shape 0) followed by a V
typedef struct __attribute__((aligned(CACHELINESIZE))) {I memhdr[AKXR(0)/SZI]; union { V primvb; I primint; } prim; } PRIM;  // two cachelines exactly in 64-bit

// Canned blocks
// NOTE: for fetching IDs we use the validitymask as a safe place to fetch 0s from.  We know that
// validitymask[15] will be 0 on any platform
#define FUNCTYPE0 ((A)(validitymask+12))  // 0 0 0 0, which has a 0 in the AT field
#define FUNCID0 ((A)(validitymask-4*(!SY_64)))  // 0 in index [15] ([19] for 32-bit), which has a 0 in the id field of V
#define SYMVAL0 ((L*)(validitymask+12))  // 0 0, which has a 0 in the val field of L
#define AFLAG0 ((A)(validitymask+12))  // 0 0, which has a 0 in the flag field of A
#define ZAPLOC0 ((A*)(validitymask+12))  // 0 used as a null pointer to the tpop stack
#define PSTK2NOTFINALASGN ((PSTK*)(validitymask+12)-2)  // 0 in position [2], signifying NOT final assignment (used for errors)
#define BREAK0 ((C*)(validitymask+12))  // 0 to indicate no ATTN requested
#define MEMSET00 ((C*)(iotavec-IOTAVECBEGIN+0))  // 8 bytes of 0, for memset
#define MEMSETFF ((C*)(iotavec-IOTAVECBEGIN+0xff))  // 8 bytes of 0xff, for memset
#define MEMSET01 ((C*)(iotavec-IOTAVECBEGIN+1))  // 8 bytes of 0x01, for memset



typedef struct {DX re;DX im;} ZX;

/* extended complex                                                        */
/* re - real part                                                          */
/* im - imaginary part                                                     */


// parser stack - should be a qword for fast copying
typedef struct {
  // Because the parse decode looks mostly at pt, make that the first thing so that it is always aligned to the beginning
  // of whatever block is usd to copy one stack element to another.
 UI4 pt;  // parser type: code for one of the 9 variants recognized.
 S filler;
 US t;  // token number for this block - 16 bits of token.  After assignment, set to -1 if final assignment
 A a;  // pointer to block
} PSTK;

// stack frame used by the parser
 typedef struct{
  PSTK* parserstkbgn;     // &start of parser stack
  PSTK* parserstkend1;    // &end+1 of parser stack
  A    sf;   // $: stack in the parser (other users of $: have their own stacks)
  US   filler;
  US   parsercurrtok;   // the token number of the word to flag if there is an error
  US  nvrtop;           /* top of nvr stack; # valid entries               */
  US  nvrotop;          // previous top of nvr stack
 } PFRAME;  // these are stacked en bloc

typedef struct {
  C*   sev;          /* comparison: sparse element value ptr            */
  I    si;           /* comparison: sparse current cell index           */
  I*   stv;          /* comparison: sparse element item indices         */
  I    swf;          /* comparison: sparse wf value                     */
  I    sxc;          /* comparison: sparse aii(x)                       */
  C*   sxv;          /* comparison: sparse AV(x)                        */
  I    syc;          /* comparison: sparse aii(y) or AS(y)[1]         */
  I*   syv;          /* comparison: sparse AV(y)                        */
 } SORTSP;   // sparse extension for sortblok

typedef struct {
  CMP  f;             /* comparison function in sort                     */
  struct JTTstruct * jt;           // jt, including the DESCEND flag
  I    n;            /* comparison: number of atoms in each item        */
  I    k;            /* comparison: byte size of each item              */
  C*   v;            /* comparison: beginning of data area              */
  SORTSP *sp;  // pointer to extension for sparse arrays
 } SORT;
